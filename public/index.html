<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CyberPuck</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        background: linear-gradient(45deg, #0d0d1a, #1a1a3a);
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: "Orbitron", monospace;
        color: #00ffcc;
        overflow: hidden;
      }
      canvas {
        border: 2px solid #ff007a;
        box-shadow: 0 0 20px #ff007a, 0 0 40px #00ffcc;
        width: 70vw;
        height: 90vh;
      }
      #status {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: #00ffcc;
        text-shadow: 0 0 10px #00ffcc, 0 0 20px #ff007a;
        font-size: clamp(16px, 2vw, 24px);
        text-align: center;
      }
      #server {
        position: absolute;
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        color: #ff007a;
        text-shadow: 0 0 10px #ff007a;
        font-size: clamp(14px, 1.8vw, 20px);
      }
      #timer {
        position: absolute;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        color: #ff00ff;
        text-shadow: 0 0 10px #ff00ff;
        font-size: clamp(14px, 1.8vw, 20px);
      }
      #newGameButton {
        position: absolute;
        top: 90px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background: transparent;
        border: 2px solid #ff007a;
        color: #00ffcc;
        font-family: "Orbitron", monospace;
        font-size: clamp(14px, 1.8vw, 18px);
        text-shadow: 0 0 5px #00ffcc;
        box-shadow: 0 0 10px #ff007a;
        cursor: pointer;
        display: none;
      }
      #newGameButton:hover {
        background: #ff007a;
        color: #0d0d1a;
        text-shadow: none;
      }
    </style>
  </head>
  <body>
    <div id="status">Ожидание второго игрока...</div>
    <div id="server">Подача: Игрок 1</div>
    <div id="timer">03:00</div>
    <button id="newGameButton" onclick="requestNewGame()">Новая игра</button>
    <script>
      let ws;
      let playerId = null;
      let paddle1 = { x: 400, y: 30, score: 0 };
      let paddle2 = { x: 400, y: 420, score: 0 };
      let ball = { x: 450, y: 225, dx: 0, dy: 0, spin: 0 };
      let gameState = "waiting";
      let servingPlayer = 1;
      let serveTimer = 10;
      let gameTimer = 180;
      let particles = [];
      let ballTrail = [];
      let hitSound, strongHitSound, tableSound, goalSound, backgroundMusic;
      let canvasWidth = 900;
      let canvasHeight = 450;
      let paddleWidth = 60;
      let paddleHeight = 15;
      let lastTouchX = null;
      let lastTouchY = null;
      let chargeStart = null;
      let serveDirection = 0;

      function preload() {
        hitSound = loadSound("/sounds/hit.mp3");
        strongHitSound = loadSound("/sounds/strong_hit.mp3");
        tableSound = loadSound("/sounds/table.mp3");
        goalSound = loadSound("/sounds/goal.mp3");
        backgroundMusic = loadSound("/sounds/background.mp3");
      }

      function setup() {
        let canvas = createCanvas(canvasWidth, canvasHeight);
        canvas.style("width", "70vw");
        canvas.style("height", "90vh");
        windowResized();
        ws = new WebSocket("wss://" + window.location.host + "/ws");

        ws.onopen = () => {
          console.log("Подключено к WebSocket");
          backgroundMusic.loop();
          backgroundMusic.setVolume(0.3);
        };

        ws.onerror = (error) => {
          console.error("WebSocket error:", error);
          document.getElementById("status").innerText =
            "Ошибка подключения к серверу!";
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);
          if (data.type === "init") {
            playerId = data.playerId;
            document.getElementById(
              "status"
            ).innerText = `Вы игрок ${playerId}. Ожидание второго игрока...`;
          } else if (data.type === "start") {
            gameState = "playing";
            servingPlayer = data.servingPlayer;
            serveTimer = data.serveTimer;
            gameTimer = data.gameTimer;
            document.getElementById(
              "status"
            ).innerText = `Счёт: ${paddle1.score} - ${paddle2.score}`;
            document.getElementById(
              "server"
            ).innerText = `Подача: Игрок ${servingPlayer}`;
            document.getElementById("timer").innerText = formatTime(gameTimer);
            document.getElementById("newGameButton").style.display = "none";
          } else if (data.type === "update") {
            paddle1.x = data.paddle1.x * (width / canvasWidth);
            paddle1.y = data.paddle1.y * (height / canvasHeight);
            paddle2.x = data.paddle2.x * (width / canvasWidth);
            paddle2.y = data.paddle2.y * (height / canvasHeight);
            ball.x = data.ball.x * (width / canvasWidth);
            ball.y = data.ball.y * (height / canvasHeight);
            ball.dx = data.ball.dx;
            ball.dy = data.ball.dy;
            ball.spin = data.ball.spin;
            paddle1.score = data.paddle1.score;
            paddle2.score = data.paddle2.score;
            servingPlayer = data.servingPlayer;
            serveTimer = data.serveTimer;
            gameTimer = data.gameTimer;
            if (data.hit) {
              createParticles(
                ball.x,
                ball.y,
                Math.abs(ball.dx) + Math.abs(ball.dy),
                color(255, 0, 122)
              );
              if (Math.abs(ball.dx) + Math.abs(ball.dy) > 15) {
                strongHitSound.play();
              } else {
                hitSound.play();
              }
            }
            if (data.wallHit) {
              createParticles(ball.x, ball.y, 10, color(0, 255, 204));
              tableSound.play();
            }
            if (data.goal) {
              createParticles(ball.x, ball.y, 50, color(255, 0, 255));
              goalSound.play();
            }
            document.getElementById(
              "status"
            ).innerText = `Счёт: ${paddle1.score} - ${paddle2.score}`;
            document.getElementById(
              "server"
            ).innerText = `Подача: Игрок ${servingPlayer}`;
            document.getElementById("timer").innerText = formatTime(gameTimer);
          } else if (data.type === "gameOver") {
            gameState = "gameOver";
            document.getElementById(
              "status"
            ).innerText = `Игра окончена! Победил игрок ${data.winner}!`;
            document.getElementById("server").innerText = "";
            document.getElementById("timer").innerText = "";
            document.getElementById("newGameButton").style.display = "block";
            document.getElementById("newGameButton").disabled = false;
            document.getElementById("newGameButton").innerText = "Новая игра";
          } else if (data.type === "error") {
            document.getElementById("status").innerText = data.message;
          }
        };

        ws.onclose = () => {
          document.getElementById("status").innerText =
            "Соединение закрыто. Перезагрузите страницу.";
          backgroundMusic.stop();
        };
      }

      function formatTime(seconds) {
        let mins = Math.floor(seconds / 60);
        let secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, "0")}:${secs
          .toString()
          .padStart(2, "0")}`;
      }

      function requestNewGame() {
        ws.send(JSON.stringify({ type: "newGame" }));
        document.getElementById("newGameButton").disabled = true;
        document.getElementById("newGameButton").innerText =
          "Ожидание второго игрока...";
      }

      function draw() {
        background(13, 13, 26, 200);
        drawCyberBackground();

        // Рисуем стол
        stroke(0, 255, 204, 50);
        strokeWeight(1);
        for (let x = 0; x < width; x += width / 30) {
          line(x, 0, x, height);
        }
        for (let y = 0; y < height; y += height / 20) {
          line(0, y, width, y);
        }
        stroke(255, 0, 122);
        strokeWeight(4);
        line(0, 0, 0, height);
        line(width, 0, width, height);
        line(0, 0, width, 0);
        line(0, height, width, height);

        // Рисуем ракетки
        fill(0, 255, 204);
        noStroke();
        drawingContext.shadowBlur = 20;
        drawingContext.shadowColor = `rgba(0, 255, 204, ${
          Math.abs(paddle1.vx || 0) / 10
        })`;
        rect(paddle1.x, paddle1.y, paddleWidth, paddleHeight);
        drawingContext.shadowColor = `rgba(0, 255, 204, ${
          Math.abs(paddle2.vx || 0) / 10
        })`;
        rect(paddle2.x, paddle2.y, paddleWidth, paddleHeight);
        drawingContext.shadowBlur = 0;

        // Рисуем след мяча
        for (let i = ballTrail.length - 1; i >= 0; i--) {
          let trail = ballTrail[i];
          fill(255, 0, 122, trail.alpha);
          noStroke();
          ellipse(trail.x, trail.y, width * 0.01, width * 0.01);
          trail.alpha -= 5;
          if (trail.alpha <= 0) {
            ballTrail.splice(i, 1);
          }
        }

        // Рисуем мяч
        fill(255, 0, 122);
        drawingContext.shadowBlur = 15;
        drawingContext.shadowColor = `rgba(255, 0, 122, ${
          Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy) / 20
        })`;
        ellipse(ball.x, ball.y, width * 0.0167, width * 0.0167);
        drawingContext.shadowBlur = 0;

        // Рисуем частицы
        for (let i = particles.length - 1; i >= 0; i--) {
          particles[i].update();
          particles[i].show();
          if (particles[i].lifetime <= 0) {
            particles.splice(i, 1);
          }
        }
      }

      function drawCyberBackground() {
        stroke(255, 0, 122, 50);
        strokeWeight(2);
        for (let i = 0; i < 10; i++) {
          let x = ((frameCount * 2 + i * 100) % (width + 100)) - 50;
          line(x, 0, x - 50, height);
        }
        stroke(0, 255, 204, 50);
        for (let i = 0; i < Bundle10; i++) {
          let y = ((frameCount + i * 80) % (height + 80)) - 40;
          line(0, y, width, y);
        }
      }

      function windowResized() {
        let newWidth = min(windowWidth * 0.7, windowHeight * 2 * 0.7);
        let newHeight = min(windowHeight * 0.9, newWidth * 0.5);
        resizeCanvas(newWidth, newHeight);
        paddleWidth = width * 0.0667;
        paddleHeight = height * 0.0333;
      }

      function keyPressed() {
        if (gameState !== "playing") return;
        let move = {};
        if (keyCode === LEFT_ARROW || key === "a" || key === "A") {
          move.x = -10;
        }
        if (keyCode === RIGHT_ARROW || key === "d" || key === "D") {
          move.x = 10;
        }
        if (
          (keyCode === UP_ARROW || key === "w" || key === "W") &&
          playerId === 1 &&
          paddle1.y > 0
        ) {
          move.y = -5;
        }
        if (
          (keyCode === DOWN_ARROW || key === "s" || key === "S") &&
          playerId === 1 &&
          paddle1.y < height / 2 - paddleHeight
        ) {
          move.y = 5;
        }
        if (
          (keyCode === UP_ARROW || key === "w" || key === "W") &&
          playerId === 2 &&
          paddle2.y > height / 2
        ) {
          move.y = -5;
        }
        if (
          (keyCode === DOWN_ARROW || key === "s" || key === "S") &&
          playerId === 2 &&
          paddle2.y < height - paddleHeight
        ) {
          move.y = 5;
        }
        if (keyCode === 32 && playerId === servingPlayer) {
          chargeStart = millis();
        }
        if (move.x || move.y) {
          ws.send(JSON.stringify({ type: "move", direction: move }));
        }
      }

      function keyReleased() {
        if (gameState !== "playing" || playerId !== servingPlayer) return;
        if (keyCode === 32 && chargeStart !== null) {
          let chargeTime = (millis() - chargeStart) / 1000;
          let charge = min(3, 1 + chargeTime * 0.75);
          ws.send(
            JSON.stringify({ type: "serve", charge, direction: serveDirection })
          );
          chargeStart = null;
          serveDirection = 0;
        }
      }

      function touchMoved() {
        if (gameState !== "playing") return;
        let touchX = mouseX;
        let touchY = mouseY;
        let move = {};
        if (lastTouchX !== null) {
          let deltaX = touchX - lastTouchX;
          let deltaY = touchY - lastTouchY;
          move.x = deltaX < -5 ? -10 : deltaX > 5 ? 10 : 0;
          if (playerId === 1 && deltaY !== 0) {
            move.y =
              deltaY < -5 && paddle1.y > 0
                ? -5
                : deltaY > 5 && paddle1.y < height / 2 - paddleHeight
                ? 5
                : 0;
          } else if (playerId === 2 && deltaY !== 0) {
            move.y =
              deltaY < -5 && paddle2.y > height / 2
                ? -5
                : deltaY > 5 && paddle2.y < height - paddleHeight
                ? 5
                : 0;
          }
          if (playerId === servingPlayer) {
            serveDirection = deltaX / 50; // Угол подачи от -1 до 1
          }
          if (move.x || move.y) {
            ws.send(JSON.stringify({ type: "move", direction: move }));
          }
        }
        lastTouchX = touchX;
        lastTouchY = touchY;
        return false;
      }

      function touchEnded() {
        if (gameState === "playing" && playerId === servingPlayer) {
          ws.send(
            JSON.stringify({
              type: "serve",
              charge: 1,
              direction: serveDirection,
            })
          );
          serveDirection = 0;
        }
        lastTouchX = null;
        lastTouchY = null;
      }

      function createParticles(x, y, intensity, col) {
        let count = Math.min(50, Math.floor(15 + intensity));
        for (let i = 0; i < count; i++) {
          particles.push(new Particle(x, y, col));
        }
      }

      class Particle {
        constructor(x, y, col) {
          this.x = x;
          this.y = y;
          this.vx = random(-5, 5);
          this.vy = random(-5, 5);
          this.lifetime = 60;
          this.color = col || color(255, 0, 122);
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.lifetime -= 1;
        }
        show() {
          noStroke();
          fill(this.color, this.lifetime * 4);
          ellipse(this.x, this.y, width * 0.012, width * 0.012);
        }
      }

      function update() {
        if (gameState === "playing") {
          ballTrail.push({ x: ball.x, y: ball.y, alpha: 100 });
          if (ballTrail.length > 20) {
            ballTrail.shift();
          }
        }
      }
    </script>
  </body>
</html>
